"""
This module provides a more fine tuned time estimation method that could
(attempt to) adapt to varying dt.
"""
# TODO: Use robust regression for linear and exponential algorithms.

import numpy as np
import scipy.optimize as sop
import time
import warnings


class EstimateTime():
    # Silence scipy non-convergence warnings.
    warnings.filterwarnings('ignore')

    def __init__(self, start_time, total, mode):
        self.start_time = start_time
        self.last_time = start_time
        self.iteration = 0
        self.total = total
        self.__elapsed = 0
        self.dt_list = []
        self.est_time_list = [0] * 2

        # If a mode is specified, the auto select function will be overridden.
        if mode is not 'auto':
            self.override = True
            self.min_key = mode
        else:
            self.override = False

        # Containers for the storage of discrepancies between the estimated
        #  time and the actual dt.
        self.lin_err = [0] * 40
        # self.average_err = [0] * 40
        self.expspos_err = [0] * 40
        self.expsneg_err = [0] * 40

        # Containers for the storage of predicted dt's.
        self.lin_est_next = [0] * 8
        # self.average_est_next = [0] * 8
        self.expspos_est_next = [0] * 8
        self.expsneg_est_next = [0] * 8

        self.expspos_v = [0, 1, 0]
        self.expsneg_v = [0, 1, 0]

    def stop_watch(self):
        self.iteration += 1
        self.__elapsed = time.time() - self.start_time
        dt = time.time() - self.last_time
        self.last_time = time.time()
        self.dt_list.append(dt)
        if self.total >= 200 and self.total < 800:
            if len(self.dt_list) > 200:
                self.dt_list.pop(0)
        elif self.total >= 800:
            if self.iteration > self.total / 4:
                self.dt_list.pop(0)

    def est(self):
        """
        Returns the estimated time in seconds. In the current version,
        five algorithms are compared and the best one will be chosen
        for the estimation.
        """
        # Default to the average algorithm before enough points are collected
        #  for regression.
        average_est_time = self.average_est()

        if self.iteration >= 15 and self.total > 20:
            # Poll estimated times from different algorithms
            lin_est_time = self.lin_est()
            expspos_est_time = self.expspos_est()
            expsneg_est_time = self.expsneg_est()

            # Record discrepancies between the estimated delta t's and the
            #  actual delta t.
            self.err_rec()

            # Review the choice of algorithm after every 15 jobs and switch
            #  to a better one if necessary.
            if not self.override:
                if ((self.iteration - 15) % 15 == 0):
                    self.least_err()

            # Return the time associated with the algorithm that offers the
            #  highest accuracy.
            if self.min_key is 'lin':
                est_time = lin_est_time
            elif self.min_key is 'average':
                est_time = average_est_time
            elif self.min_key is 'expspos':
                est_time = expspos_est_time
            elif self.min_key is 'expsneg':
                est_time = expsneg_est_time

            # Append the latest estimated time to the estimated time list
            #  and remove the first element to make room for more elements.
            self.est_time_list.append(est_time)
            self.est_time_list.pop(0)

            # Average the past 2 estimated times to make for a smoother
            #  estimation.
            if self.min_key is not 'average':
                est_time = sum(self.est_time_list) / len(self.est_time_list)

        else:
            self.est_time_list.append(average_est_time)
            self.est_time_list.pop(0)
            est_time = average_est_time

        # Bypasses negative estimates occasionally generated by the linear
        #  algorithm and huge numbers occasionally generated by the positive
        #  exponential algorithm. 3.2e7 is a little over a year.
        if est_time < 0 or est_time > 3.2e7:
            est_time = 'invalid'
            if not self.override:
                self.min_key = 'expsneg'
        else:
            # Remedy infinities and NAN's often generated by the exponential
            #  algorithms.
            try:
                est_time = int(round(est_time))
            except OverflowError:
                est_time = 'inf'
                if not self.override:
                    self.min_key = 'expsneg'
            except ValueError:
                est_time = 'nan'
                if not self.override:
                    self.min_key = 'expsneg'
        return est_time

    def err_rec(self):
        """
        Records the errors of the estimated time for each algorithm.
        """
        last_dt_avg = self.dt_list[-8]

        # Records the discrepancies
        self.lin_err.append(abs(self.lin_est_next[0] - last_dt_avg))
        self.expspos_err.append(abs(self.expspos_est_next[0] - last_dt_avg))
        self.expsneg_err.append(abs(self.expsneg_est_next[0] - last_dt_avg))
        # self.average_err.append(abs(self.average_est_next[0] - last_dt_avg))

        # Removes the oldest entry
        self.lin_err.pop(0)
        # self.average_err.pop(0)
        self.expspos_err.pop(0)
        self.expsneg_err.pop(0)

    def least_err(self):
        """
        Looks into the error records of all the algorithms and selects the
        one with the smallest error.
        """
        errs = {
            "lin": abs(sum(self.lin_err)),
            # "average": abs(sum(self.average_err)),
            "expspos": abs(sum(self.expspos_err)),
            "expsneg": abs(sum(self.expsneg_err))
        }
        self.min_key = min(errs, key=errs.get)

    def average_est(self):
        est_time = self.__elapsed / self.iteration * (self.total - self.iteration)

        # To prevent zero division.
        # if not self.iteration == self.total:
        #     self.average_est_next.append(est_time / (self.total - self.iteration))
        #     self.average_est_next.pop(0)
        return est_time

    def least_sq_fit(self, M, y):
        M = np.matrix(M)
        MTM = M.T * M
        v = MTM.I * M.T * y
        return v

    def linv(self):
        """
        Calculates the coefficients of model functions for linear
        least-squares best fit for the y = ax + b model.
        """
        M = np.empty([len(self.dt_list), 2])
        M[:, 0] = np.ones([len(self.dt_list)])
        M[:, 1] = np.arange(self.iteration, len(self.dt_list) + self.iteration)
        y = np.matrix(self.dt_list).T
        lin_v = self.least_sq_fit(M, y)
        return lin_v

    def lin_est(self):
        lin_v = self.linv()
        # Find the time estimate by integrating over the best fit function
        #  from the current point to the last point
        est_time = lin_v[1, 0] * (self.total**2 - self.iteration**2) / 2
        est_time += lin_v[0, 0] * (self.total - self.iteration)

        # Find the time estimate for the job 6 points in the future.
        #  For evaluation of the accuracy of the function.
        est_time_next = lin_v[1, 0] * ((self.iteration + 8)**2 - (self.iteration + 7)**2) / 2
        est_time_next += lin_v[0, 0]
        self.lin_est_next.append(est_time_next)
        self.lin_est_next.pop(0)
        return est_time

    def nonlin_regress_fit(self, func):
        x_lower_lim = self.iteration - len(self.dt_list)
        x_upper_lim = self.iteration
        v, cov = sop.curve_fit(func, np.arange(x_lower_lim, x_upper_lim),
                               self.dt_list, method='trf',
                               loss='soft_l1', f_scale=0.1)
        return v

    def expspos_est(self):
        def exp_pos(x, a, b, c):
            return a * np.exp(b * x) + c

        # Remedies convergence errors of scipy
        try:
            self.expspos_v = self.nonlin_regress_fit(exp_pos)
        except RuntimeWarning:
            expspos_v = self.expspos_v
        except RuntimeError:
            expspos_v = self.expspos_v
        except ValueError:
            expspos_v = self.expspos_v
        else:
            expspos_v = self.expspos_v

        # Find the time estimate by integrating over the best fit function
        #  from the current point to the last point
        est_time = np.exp(expspos_v[1] * self.total)
        est_time -= np.exp(expspos_v[1] * self.iteration)
        est_time *= expspos_v[0] / expspos_v[1]
        est_time += expspos_v[2] * (self.total - self.iteration)

        # Find the time estimate for the job 6 points in the future.
        #  For evaluation of the accuracy of the function.
        est_time_next = np.exp(expspos_v[1] * self.iteration + 8)
        est_time_next -= np.exp(expspos_v[1] * self.iteration + 7)
        est_time_next *= expspos_v[0] / expspos_v[1]
        est_time_next += expspos_v[2]
        self.expspos_est_next.append(est_time_next)
        self.expspos_est_next.pop(0)
        return est_time

    def expsneg_est(self):
        def exp_neg(x, a, b, c):
            return a * np.exp(-b * x) + c

        # Remedies convergence errors of scipy
        try:
            self.expsneg_v = self.nonlin_regress_fit(exp_neg)
        except RuntimeWarning:
            expsneg_v = self.expsneg_v
        except RuntimeError:
            expsneg_v = self.expsneg_v
        except ValueError:
            expsneg_v = self.expspos_v
        else:
            expsneg_v = self.expsneg_v

        # Find the time estimate by integrating over the best fit function
        #  from the current point to the last point
        est_time = np.exp(-1 * expsneg_v[1] * self.total)
        est_time -= np.exp(-1 * expsneg_v[1] * self.iteration)
        est_time *= expsneg_v[0] / expsneg_v[1]
        est_time += expsneg_v[2] * (self.total - self.iteration)

        # Find the time estimate for the job 6 points in the future.
        #  For evaluation of the accuracy of the function.
        est_time_next = np.exp(-1 * expsneg_v[1] * self.iteration + 8)
        est_time_next -= np.exp(-1 * expsneg_v[1] * self.iteration + 7)
        est_time_next *= expsneg_v[0] / expsneg_v[1]
        est_time_next += expsneg_v[2]
        self.expsneg_est_next.append(est_time_next)
        self.expsneg_est_next.pop(0)
        return est_time
